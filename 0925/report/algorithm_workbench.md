1. Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.
~~~
CONST_DEC = 25      ; 10진수
CONST_BIN = 11001b  ; 2진수
CONST_OCT = 31o     ; 8진수 (또는 31q)
CONST_HEX = 19h     ; 16진수
~~~
2. Find out, by trial and error, if a program can have multiple code and data segments.
  - 답: 예, 가능합니다. 하나의 프로그램은 여러 개의 .data 세그먼트와 .code 세그먼트를 가질 수 있습니다. 어셈블러와 링커는 이들을 목적에 맞게 조합하여 최종 실행 파일을 만듭니다.

3. Create a data definition for a doubleword that stored it in memory in big endian format.
  - 답: x86 시스템은 리틀 엔디안을 사용하므로, 빅 엔디안으로 저장하려면 바이트 순서를 직접 명시해야 합니다. 예를 들어, 12345678h를 빅 엔디안으로 저장하려면 다음과 같이 정의합니다.
~~~
bigEndianVal DB 12h, 34h, 56h, 78h
~~~
4. Find out if you can declare a variable of type DWORD and assign it a negative value. What does this tell you about the assembler’s type checking?
  - 답: 예, myVar DWORD -1과 같이 선언할 수 있습니다. 어셈블러는 이 음수 값을 2의 보수 형태(FFFFFFFFh)로 자동 변환하여 저장합니다. 이것은 어셈블러의 타입 검사가 매우 유연하거나 약하다는 것을 보여줍니다. DWORD는 부호 없는 타입이지만, 부호 있는 값을 할당하는 것을 허용하며 프로그래머의 의도에 따라 데이터를 해석합니다.

5. Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?
  - 답: 두 명령어의 기계어 코드는 다를 가능성이 높습니다. EAX 레지스터는 누산기(accumulator)로 자주 사용되기 때문에, 다른 일반 레지스터(EDX 등)에 대한 연산보다 더 짧고 최적화된 기계어 코드를 갖는 경우가 많습니다. 리스팅 파일을 보면 ADD EAX, 5의 기계어 코드가 ADD EDX, 5의 코드와 다르거나 더 짧을 수 있습니다.

6. Given the number 456789ABh, list out its byte values in little-endian order.
  - 답: 리틀 엔디안은 가장 낮은 바이트(LSB)부터 메모리의 낮은 주소에 저장됩니다. 따라서 메모리에는 다음과 같은 순서로 저장됩니다:
ABh, 89h, 67h, 45h

7. Declare an array of 120 uninitialized unsigned doubleword values.
~~~
myArray DWORD 120 DUP(?)
~~~
8. Declare an array of byte and initialize it to the first 5 letters of the alphabet.
~~~
alpha BYTE "ABCDE";
또는
alpha BYTE 'A', 'B', 'C', 'D', 'E'
~~~
9. Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value.
답: 32비트 부호 있는 정수의 가장 작은 값은 -2,147,483,648 입니다.
~~~
smallestVal SDWORD -2147483648
~~~
10. Declare an unsigned 16-bit integer variable named wArray that uses three initializers.
~~~
wArray WORD 10, 20, 30
~~~
11. Declare a string variable containing the name of your favorite color. Initialize it as a null-terminated string.
~~~
favColor BYTE "Blue", 0
~~~
12. Declare an uninitialized array of 50 signed doublewords named dArray.
~~~
dArray SDWORD 50 DUP(?)
~~~
13. Declare a string variable containing the word “TEST” repeated 500 times.
~~~
testString BYTE 500 DUP("TEST")
~~~
14. Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.
~~~
bArray BYTE 20 DUP(0)
~~~
15. Show the order of individual bytes in memory (lowest to highest) for the following doubleword variable: val1 DWORD 87654321h
  - 답: 리틀 엔디안 순서에 따라 메모리의 낮은 주소부터 높은 주소 순으로 다음과 같이 저장됩니다.
~~~
21h, 43h, 65h, 87h
~~~
