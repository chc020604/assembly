1. Integer Expression Calculation
Using the AddTwo program from Section 3.2 as a reference, write a program that calculates the following expression, using registers: A = (A + B) − (C + D). Assign integer values to the EAX, EBX, ECX, and EDX registers.
~~~
.386
.model flat, stdcall
.stack 4096
ExitProcess PROTO, dwExitCode:DWORD

.code
main PROC
    mov eax, 100
    mov ebx, 50
    mov ecx, 20
    mov edx, 10

    add eax, ebx
    add ecx, edx
    sub eax, ecx

    INVOKE ExitProcess, 0
main ENDP
END main
~~~
2. Symbolic Integer Constants
Write a program that defines symbolic constants for all seven days of the week. Create an array variable that uses the symbols as initializers.

~~~
.data
SUNDAY    = 0
MONDAY    = 1
TUESDAY   = 2
WEDNESDAY = 3
THURSDAY  = 4
FRIDAY    = 5
SATURDAY  = 6

dayArray DWORD SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
~~~
3. Data Definitions
Write a program that contains a definition of each data type listed in Table 3-2 in Section 3.4. Initialize each variable to a value that is consistent with its data type.
~~~
.data
var_byte    BYTE    255
var_sbyte   SBYTE   -128
var_word    WORD    65535
var_sword   SWORD   -32768
var_dword   DWORD   12345678h
var_sdword  SDWORD  -100000
var_qword   QWORD   123456789ABCDEF0h
var_tbyte   TBYTE   12345678901234567890
var_real4   REAL4   1.234
var_real8   REAL8   -2.345e100
var_real10  REAL10  3.456e-2000
~~~
4. Symbolic Text Constants
Write a program that defines symbolic names for several string literals (characters between quotes). Use each symbolic name in a variable definition.
~~~
.data
MSG_GREETING EQU <"Hello, World!", 0>
MSG_PROMPT   EQU <"Enter your input: ">
MSG_ERROR    EQU <"Error: Invalid data.">

greetingStr BYTE MSG_GREETING
promptStr   BYTE MSG_PROMPT
errorStr    BYTE MSG_ERROR
~~~
5. Listing File for AddTwoSum
Generate a listing file for the AddTwoSum program and write a description of the machine code bytes generated for each instruction. You might have to guess at some of the meanings of the byte values.
~~~
답: 아래는 mov eax, 5 와 add eax, 6 명령어에 대한 가상 리스팅 파일과 설명입니다.

가상 리스팅 파일 (.lst):

1 00000000           .386
...
5 00000000  B8 00000005    mov eax, 5
6 00000005  83 C0 06       add eax, 6
...

기계어 바이트 설명:

mov eax, 5 -> B8 00000005

B8: MOV 명령어를 사용해 32비트 즉시 값을 EAX 레지스터에 저장하라는 Opcode입니다.

00000005: EAX에 저장될 32비트 값 5를 리틀 엔디안 방식으로 표현한 것입니다. (05 00 00 00)

add eax, 6 -> 83 C0 06

83: 32비트 레지스터에 8비트 부호 확장된 즉시 값을 더하는 연산 그룹의 Opcode입니다.

C0: ADD 연산을 EAX 레지스터에 수행하라는 의미의 추가 바이트입니다.

06: EAX에 더해질 8비트 값 6입니다.
~~~
6. AddVariables Program
Modify the AddVariables program so it uses 64-bit variables. Describe the syntax errors generated by the assembler and what steps you took to resolve the errors.

답:
수정 전 (가상 32비트 코드):
~~~
.386
.model flat, stdcall
.data
val1 DWORD 10
val2 DWORD 20
sum  DWORD ?
.code
main PROC
    mov eax, val1
    add eax, val2
    mov sum, eax
main ENDP
END main
~~~
수정 시도 (64비트 변수 사용):
~~~
.386
.model flat, stdcall
.data
val1 QWORD 10
val2 QWORD 20
sum  QWORD ?
.code
main PROC
    mov rax, val1
    add rax, val2
    mov sum, rax
main ENDP
END main
~~~
